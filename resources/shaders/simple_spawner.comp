#version 430
layout(local_size_x = 32, local_size_y = 1) in;

#include "../shader_includes/particle_types.in"

layout(std430, binding = 0) buffer ConfigData {
    ParticleSystemConfig config;
};

layout(std430, binding = 1) buffer ParticleDataNow
{
    Particle particles_now[];
};

layout(std430, binding = 2) buffer ParticleDataPre
{
    Particle particles_pre[];
};

layout(std430, binding = 5) buffer ParticleIndicesAlive
{
    uint alive_particles_idx[];
};

layout(std430, binding = 7) buffer ParticleIndicesdead
{
    uint dead_particles_idx[];
};

layout(binding = 3, offset = 4) uniform atomic_uint num_particles_alive;

const uint max_particles_to_instantiate = 5;

void main() {
    const uint thread_id = gl_GlobalInvocationID.x;
    // Do not overcreate particles
    if(thread_id >= max_particles_to_instantiate){
        return;
    }
    const uint actual_particles_count = atomicCounter(num_particles_alive);
    barrier();
    if(actual_particles_count + thread_id >= config.max_particles) {
        return;
    }

    const uint new_part_idx_idx = atomicCounterIncrement(num_particles_alive);
    const uint new_part_idx = dead_particles_idx[config.max_particles - 1 - new_part_idx_idx];
    
    particles_now[new_part_idx].pos = vec3(5.0) + vec3(0.3 * float(thread_id), 0.2 * float(thread_id), 0.0 );
    particles_pre[new_part_idx].pos = particles_now[new_part_idx].pos;

    alive_particles_idx[new_part_idx_idx] = new_part_idx;
}
