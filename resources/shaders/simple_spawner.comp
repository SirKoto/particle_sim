#version 430
layout(local_size_x = 32, local_size_y = 1) in;

#include "../shader_includes/particle_types.in"

layout(std430, binding = BINDING_SYSTEM_CONFIG) buffer ConfigData {
    ParticleSystemConfig config;
    ParticleSpawnerConfig spawn_config;
};

layout(std430, binding = BINDING_PARTICLES_IN) buffer ParticleDataNow
{
    Particle particles_now[];
};

layout(std430, binding = BINDING_PARTICLES_OUT) buffer ParticleDataPre
{
    Particle particles_pre[];
};

layout(std430, binding = BINDING_ALIVE_LIST_IN) buffer ParticleIndicesAlive
{
    uint alive_particles_idx[];
};


layout(std430, binding = BINDING_DEAD_LIST) buffer ParticleIndicesDead
{
    uint dead_particles_idx[];
};

layout(binding = BINDING_ATOMIC_ALIVE_IN, offset = 4) uniform atomic_uint num_particles_alive;
layout(binding = BINDING_ATOMIC_DEAD) uniform atomic_uint num_particles_dead;

layout(location = 0) uniform float time;
layout(location = 1) uniform uint particles_to_instantiate;


void main() {
    const uint thread_id = gl_GlobalInvocationID.x;
    // Do not overcreate particles
    if(thread_id >= particles_to_instantiate){
        return;
    }
    const uint actual_particles_count = atomicCounter(num_particles_alive);
    barrier();
    if(actual_particles_count + thread_id >= config.max_particles) {
        return;
    }

    const uint new_part_idx_idx = atomicCounterIncrement(num_particles_alive);
    // const uint dead_part_idx_idx = config.max_particles - 1 - new_part_idx_idx;
    const uint dead_part_idx_idx = atomicCounterDecrement(num_particles_dead);
    const uint new_part_idx = dead_particles_idx[dead_part_idx_idx];
    
    Particle p;
    p.pos = spawn_config.pos + vec3(0.3 * float(thread_id), 0.2 * float(thread_id), 0.0 );
    p.lifetime = spawn_config.mean_lifetime;
    particles_now[new_part_idx] = p;
    particles_pre[new_part_idx].pos = particles_now[new_part_idx].pos;

    alive_particles_idx[new_part_idx_idx] = new_part_idx;
}
