#version 430
layout(local_size_x = 32, local_size_y = 1) in;

#include "../shader_includes/particle_types.in"

layout(std430, binding = 0) buffer ConfigData{
    ParticleSystemConfig config;
};

layout(std430, binding = 1) buffer ParticleDataIn
{
    Particle particles_in[];
};

layout(std430, binding = 2) buffer ParticleDataOut
{
    Particle particles_out[];
};

layout(std430, binding = 5) buffer ParticleIndicesAlive
{
    uint alive_particles_idx[];
};

layout(std430, binding = 6) buffer ParticleIndicesAliveNext
{
    uint alive_next_particles_idx[];
};

layout(binding = 3, offset = 4) uniform atomic_uint particles_alive_in;
layout(binding = 4, offset = 4) uniform atomic_uint particles_alive_out;


layout(location = 0) uniform float dt;

const float bounce = 1.0;

void main() {
    const uint thread_id = gl_GlobalInvocationID.x;
    if(thread_id > config.max_particles) {
        return;
    }

    const uint idx = alive_particles_idx[thread_id];
    // verlet solver
    const vec3 old_pos = particles_out[idx].pos;
    vec3 actual_pos = particles_in[idx].pos;
    vec3 new_pos = actual_pos + config.k_v * (actual_pos - old_pos) - vec3(0.0, dt * dt * config.gravity, 0.0);
    
    // Colide against 5 walls
    // Bottom
    if(new_pos.y < 0.0) {
        const float delta_y = new_pos.y - actual_pos.y;
        //new_pos.y = new_pos.y - (1.0 + config.bounce) * new_pos.y;
        //actual_pos.y = new_pos.y - (delta_y - (1.0 + config.bounce) * delta_y);
        new_pos.y = - new_pos.y * config.bounce ;
        actual_pos.y = new_pos.y + delta_y * config.bounce;
    }
    // Back
    if(new_pos.z < 0.0) {
        const float delta_z = new_pos.z - actual_pos.z;
        new_pos.z = - new_pos.z * config.bounce ;
        actual_pos.z = new_pos.z + delta_z * config.bounce;
    }
    // Left
    if(new_pos.x < 0.0) {
        const float delta_x = new_pos.x - actual_pos.x;
        new_pos.x = - new_pos.x * config.bounce;
        actual_pos.x = new_pos.x + delta_x * config.bounce;
    }
    // Front
    if(new_pos.z > config.simulation_space_size) {
        const float delta_z = new_pos.z - actual_pos.z;
        new_pos.z = new_pos.z - (1.0 + config.bounce) * (new_pos.z - config.simulation_space_size);
        actual_pos.z = new_pos.z + delta_z * config.bounce;
    }
    // Right
    if(new_pos.x  > config.simulation_space_size) {
        const float delta_x = new_pos.x - actual_pos.x;
        new_pos.x = new_pos.x - (1.0 + config.bounce) * (new_pos.x - config.simulation_space_size);
        actual_pos.x = new_pos.x + delta_x * config.bounce;
    }

    particles_in[idx].pos = actual_pos;
    particles_out[idx].pos = new_pos;

    // update alive
    alive_next_particles_idx[atomicCounterIncrement(particles_alive_out)] = idx;
    
}
